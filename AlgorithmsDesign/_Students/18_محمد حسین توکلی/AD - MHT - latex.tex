\documentclass[10pt,a4paper]{article}

\usepackage[linguistics]{forest}
 %\PassOptionsToPackage{usenames,dvipsnames,svgnames}{xcolor}  
 %\usepackage{tikz}
%\usetikzlibrary{arrows,positioning,automata}
 %\usepackage{mathtools}
 %\usepackage{listings}
 %\usepackage{xcolor}
%\usepackage{booktabs} % For prettier tables
 %\usepackage{multirow} % Required for multirows
 %\usepackage{siunitx} % Required for alignment
 %\sisetup{
 % round-mode          = places, % Rounds numbers
 % round-precision     = 2, % to 2 places
%}
 
\usepackage{siunitx} 
\usepackage{ragged2e}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xepersian}
\settextfont{XM Yekan}
\definecolor{c_purple}{HTML}{7030A0}
\definecolor{c_green}{HTML}{00B050}
\definecolor{c_orange}{HTML}{FFC000}
\definecolor{c_darkred}{HTML}{C00000}
\definecolor{c_skyblue}{HTML}{0070C0}
\definecolor{c_gold}{HTML}{FFC000}


\begin{document}


	\begin{table}
		\centering
		\begin{tabular}{r!{\color{c_gold}\vrule width 0.5pt}r}
			\\ \textcolor{c_darkred}{نام و نام خانوادگی :}  &   \\[10pt]
			 & \textcolor{c_skyblue}{محمد حسین توکلی} \\[10pt]
			\textcolor{c_darkred}{شماره دانشجویی :}  &   \\[10pt]
			 & \textcolor{c_skyblue}{963874792} \\[10pt]
			 \textcolor{c_darkred}{درس :}  &   \\[10pt]
			 & \textcolor{c_skyblue}{طراحی الگوریتم ها} \\[10pt]
			 \textcolor{c_darkred}{موضوع :}  &   \\[10pt]
			 & \textcolor{c_skyblue}{پاسخ سوالات فرد تابستان 98 + سوالات زوج نیمسال دوم 93-94 | ردیف 18} \\[10pt]
			 \textcolor{c_darkred}{تاریخ :}  &   \\[10pt]
			 & \textcolor{c_skyblue}{شهریور 1399} \\[10pt]
		\end{tabular}
	\end{table}
	
	\title{}
	\date{}
	
	\pagenumbering{gobble}
	\maketitle
	\newpage
	\pagenumbering{arabic}
	

	\paragraph{\textbf{تابستان 98 – سوالات فرد}}
	\paragraph{\textcolor{c_orange}{سوالات تستی:}}




	\paragraph{1-}تعداد گره ها در درخت فضای حالت برای الگوریتم عقبگرد برای مساله رنگ آمیزی m کدام است؟ ( m تعداد رنگ ها و n تعداد رئوس گراف می باشد.)
	
	\begin{flushright} 
		\,\,1. $\frac{m^{n+1}}{m}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $\frac{m^{n+1}+1}{m+1}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $\frac{n^{m+1}-1}{n-1}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{4. $\frac{m^{n+1}-1}{m-1}$}
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ: 
		بر اساس صفحه 269 کتاب، تعداد گره ها برای این الگوریتم برابر است با\\
		$1+m+m^{2}+⋯+m^{n}=\sum^{n}_{k=0}m^{k}=\frac{m^{n+1}-1}{m-1}$ . لذا گزینه چهارم صحیح است.\\}}
	\end{flushright}




	\paragraph{3-}یدگی زمانی حاصل ضرب دو ماتریس n x n کدام است؟
	
	\begin{flushright} 
		\,\,1. $\theta(n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $\theta(n^2)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $\theta(log⁡n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{4. $\theta(n^3)$}
	\end{flushright}
	
	
	\begin{flushright} 
	\justify{\textcolor{c_purple}{پاسخ: 
		بر اساس صفحه 107 کتاب، برای ضرب دو ماتریس $n*n$ به $n$ ضرب نیاز داریم 
		و از آنجا که ماتریس حاصلضرب دارای $n^2$ عنصر است، با ضرب تعداد $n$ عملیات ضرب در $n^2$ عنصر، 
		زمان لازم برای بدست آوردن ماتریس حاصلضرب $\theta(n^3)$ خواهد بود.\\}}
	\end{flushright}




	\paragraph{5-}دو مرحله روش حدس و استقرا کدام است؟
	 
	\begin{flushright} 
		\,\,1. حدس جواب، به کارگیری استقرا ریاضی برای یافتن متغیر ها\,\,\,\,\, \\
		\textcolor{c_green}{\,2. حدس جواب، به کارگیری استقرا ریاضی برای یافتن ثابت ها}\,\,\,\,\, \\
		3. یافتن قطعی جواب، به کارگیری استقرا ریاضی برای یافتن متغیر ها\,\,\,\,\, \\
		4. یافتن قطعی جواب، به کارگیری استقرا ریاضی برای یافتن ثابت ها 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 53 کتاب، روش حدس و استقرا برای حل رابطه بازگشتی دارای دو مرحله ی حدس جواب 
		و بکارگیری استقرا ریاضی برای یافتن ثابتها و نشان دادن صحت حدس اولیه می باشد. همچنین با توجه به نام روش، 
		مشخص است که در روش مذکور دنبال یافتن جواب قطعی نیستیم و نیز متغیرها همانگونه که از نامشان پیداست 
		متغیر بوده و قرار نیست از طریق استقرا آنها را بیابیم.
		 لذا گزینه های یک و سه و چهار اشتباه بوده و تنها گزینه دوم صحیح است.\\}}
	\end{flushright}




	\paragraph{7-}یکی از روش های خوب برای حل یا حدس روابط بازگشتی از طریق تکرار، استفاده از کدام روش است؟
	 
	\begin{flushright} 
		\,\,1. روش مرتب سازی ادغامی\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. روش مرتب سازی سریع\\
		\textcolor{c_green}{3. روش درخت بازگشت}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. روش بهینه سازی 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 62 کتاب، در روش درخت بازگشت، مقدار اولیه عبارت غیر بازگشتی در ریشه درخت قرار می گیرد. 
		در سطح بعدی درخت به تعداد جملات بازگشتی گره ایجاد می شود و تا زمانی که n به مقدار ثابت نرسیده تشکیل 
		سطح درخت تکرار می شود.
		 لذا یکی از روش های خوب حل یا حدس روابط بازگشتی از طریق تکرار، روش درخت بازگشت می باشد.\\}}
	\end{flushright}




	\paragraph{9-}زمان جستجوی موفق در بدترین حالت در درخت تصمیم دودوئی کدام است؟
	 
	\begin{flushright} 
		\,\,1. $O(n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $O(n^{2})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $O(n\,log\,n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{4.  $O(log\,n)$}
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 53 کتاب، اگر X در محدوده $[2^{k-1},2^{K}]$ باشد آنگاه الگوریتم BinSrch حداکثر $k$ مقایسه عنصر 
		برای یک جستجوی موفق انجام می دهد. و چون $k -1 \leq  Log\,n < k$ ، لذا زمان یک جستجوی موفق در بدترین حالت 
		$O(Log n)$ خواهد بود.\\}}
	\end{flushright}





	\paragraph{11-}پیچیدگی زمانی الگوریتم مرتب سازی سریع در بدترین حالت و حالت متوسط به ترتیب از راست به چپ کدام است؟
	 
	\begin{flushright} 
		\textcolor{c_green}{\,\,1. $\theta(n\,Ln\,n) \,, \,\theta(n^{2}) $}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $ \theta(n^{2})\, , \,\theta(n^{2})$\\
		3. $ \theta(n^{2})\, ,\,\theta(n\,Ln\,n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. $\theta(n\,Ln\,n)\, , \,\theta(n\,Ln\,n)$ 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ: 
		بر اساس صفحه 104 کتاب، در بدترین حالت داریم: 
		\begin{flushleft}
			$T(n) \,\in
			\begin{cases}
				0 & if n<1\\
				T(n-1)+n-1 & if n \geq 1
			\end{cases}$
			\lr{$T(n)=T(n-1)+(n-1)=T(n-2)+(n-2)+(n-1)=$ ... $=\frac{n(n-1)}{2}$}\\
			$\Rightarrow \mathbf{T(n)  \in∈\theta(n^{2})}$
			\begin{flushright} 
			و بر اساس صفحه 106 کتاب، در حالت متوسط داریم:
			\end{flushright}
			$T(n)= \sum^{k}_{i=1} S_i P_i=(\frac{1}{n}) \sum^{n}_{P=1} T(P-1)+T(n-P)+n-1 \,,\, a_n=\frac{T(n)}{n+1}$\\
			$a_n =
			\begin{cases}
				0 & if n<1\\
				a_{n-1} + \frac{2(n-1)}{n(n+1)} & if n \geq 1
			\end{cases}$\\
			\lr{$a_n=a_{n-1}+2(\frac{2n-1}{n}-\frac{2n}{n+1})=$ ... $\leq \sum^{k}_{i=1}\frac{1}{k} = 2 Ln \, n \Rightarrow T(n)\leq 2(n+1)Ln\, n $}\\
			$\Rightarrow \mathbf{T(n) \in∈\theta(n\, Ln\, n)}$
		\end{flushleft}
		لذا بر اساس مقادیر به دست آمده، گزینه اول صحیح است.\\}}
	\end{flushright}
	
	
	
	
	\paragraph{13-}در کدام الگوریتم زیر، برای یافتن کلیه کوتاهترین مسیرها از مبدا واحد به مقصدهای متفاوت به کار می رود و همچنین طول یک مسیر را برابر مجموع وزن یال های آن مسیر در نظر می گیرد؟
	 
	\begin{flushright} 
		\,\,1. الگوریتم پریم\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{\,2. الگوریتم دیکسترا}\,\,\,\,\,\,\,\,\,\,
		3. الگوریتم کروسکال\,\,\,\,\,\,\,\,\,\,
		4. الگوریتم فلوید 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 157 کتاب، الگوریتم دیکسترا کلیه کوتاهترین مسیرها از منبع واحد به مقصدهای متفاوت را 
		محاسبه می کند. طول یک مسیر را برابر مجموع وزن یال های آن مسیر در نظر می گیرد. 
		همچنین رئوس شروع کننده روی مسیر را به عنوان راس منبع یا همان source و 
		آخرین راس را به عنوان راس مقصد یا همان Destenation می شناسد.\\}}
	\end{flushright}




	\paragraph{15-}کدام ویژگی در خصوص مسائلی که به روش برنامه نویسی پویا حل می شود، به درستی بیان شده است؟
	 
	\begin{flushright} 
		\,\,1. در همه الگوریتم های برنامه نویسی پویا، مساله بهینه سازی موضوعی کلیدی است.\,\,\,\,\, \\
		\,2. مسائل را از بالاترین سطح به طرف پایین ترین سطح حل می کند.\,\,\,\,\, \\
		3. در هر سطح، بعضی از مسائل آن سطح حل می گردند و بقیه به سطح بعد منتقل می شود.\,\,\,\,\, \\
		\textcolor{c_green}{4. برای حل هر مساله سطح L می توانیم از کلیه مسائل سطوح پایین تر که لازم باشد، استفاده کنیم.}
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 196 کتاب، بر خلاف روش تقسیم و حل، که برای حل هر مساله سطح $L$ تنها از مسائل سطح $L-1$ 
		استفاده می کند، در روش برنامه نویسی پویا برای حل هر مساله سطح $L$ میتوانیم از کلیه مسائل سطوح پایین تر 
		که لازم باشد استفاده کنیم. همچنین بر اساس همین صفحه، در اغلب الگوریتم های برنامه نویسی پویا مساله 
		بهینه سازی کلیدی است، نه در همه ی موارد. و نیز در الگوریتم برنامه نویسی پویا، مسائل را از پایین ترین سطح بطرف 
		بالاترین سطح حل می کنیم و نه برعکس. و نیز در هر سطح کلیه مسائل موجود آن سطح حل می گردند 
		و نتایج نگهداری می شوند، نه بعضی مسائل. لذا گزینه های یک تا سه اشتباه بوده و گزینه چهارم صحیح است.\\}}
	\end{flushright}




	\paragraph{17-}پیچیدگی زمانی مساله فروشنده دوره گرد، با استفاده از روش برنامه نویسی پویا کدام است؟
	 
	\begin{flushright} 
		\,\,1. $\theta(2^{n})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2.  $\theta(n2^{n})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{3. $\theta(n^{2}2^{n})$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. $\theta(n^{2})$ 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ: 
		بر اساس صفحه 223 کتاب، داریم: 
		\begin{flushleft}
			$\sum^{n}_{k=1} k\binom{n}{k} =n\,2^{n-1} \,,\, T(n)= \sum^{n-2}_{k=1} (n-1-k) k \binom{n-1}{k} = (n-1) \sum^{n-2}_{k=1} k \binom{n-2}{k} $\\
			\lr{$T(n)=(n-1)(n-2) 2^{n-3} \Rightarrow \mathbf{T(n) \in \theta(n^{2}\,2^{n})}$}\\
		\end{flushleft}
		لذا بر اساس مقادیر محاسبه شده، گزینه سوم صحیح است.\\}}
	\end{flushright}




	\paragraph{19-}الگوریتم های عقبگرد برای حل مسائلی از قبیل کوله پشتی صفر و یک، کدام پیچیدگی زمانی را دارد؟
	 
	\begin{flushright} 
		\,\,1. خطی\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{\,2. نمایی}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. بدتر از نمایی\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. بهتر از نمایی 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 252 و نیز 282 کتاب، الگوریتم عقبگرد برای مسائلی از قبیل کوله پشتی صفر و یک در بدترین حالت 
		باز هم نمایی هستند و تنها با کاهش حالت ها زمان اجرا را کاهش میدهند. لذا گزینه دوم صحیح است.\\}}
	\end{flushright}




	\paragraph{21-}فضای مساله ای که با استفاده از روش انشعاب و تحدید حل می شود باید چگونه نمایش داده شود؟
	 
	\begin{flushright} 
		\,\,1. باید با یک درخت قابل نمایش باشد.\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. باید با یک پشته قابل نمایش باشد.\\
		\textcolor{c_green}{3. باید با یک گراف قابل نمایش باشد.}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. باید با یک لیست پیوندی قابل نمایش باشد. 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 287 کتاب، فضای حالت مساله ای که قرار است با استفاده از روش انشعاب و تحدید حل گردد، 
		باید با یک گراف قابل نمایش باشد. لذا گزینه سوم صحیح است.\\}}
	\end{flushright}




	\paragraph{23-}مسائلی که الگوریتم کارا (چند جمله ای) برای آنها ابداع نشده است ولی غیر ممکن بودن آن نیز هنوز به اثبات نرسیده، کدام مسائل هستند؟
	 
	\begin{flushright} 
		\,\,1. P\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2 .Np\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. Np-hard\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{4. Np کامل} 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 311 کتاب، مسائلی که الگوریتم کارا برایشان ابداع نشده ولی غیر ممکن بودنشان نیز 
		هنوز به اثبات نرسیده را مسائل Np کامل گویند. لذا با توجه به اینکه P توسط الگوریتم های قطعی با مرتبه زمانی چند جمله ای 
		قابل حل هستند و Np نیز توسط الگوریتم های غیر قطعی با مرتبه زمانی چند جمله ای می توانند قابل حل باشند که 
		ممکن است الگوریتم چند جمله ای برای حل مساله داشته باشیم و یا نداشته باشیم و با توجه به اینکه  Np-hardنیز 
		حداقل به سختی سختترین مسائل در ان پی است و حتی ممکن است برخی مسائل آن در Np نباشد. 
		لذا تنها گزینه چهارم صحیح است.\\}}
	\end{flushright}




	\paragraph{25-}الگوریتم رام نشدنی کدام است؟
	 
	\begin{flushright} 
		1. الگوریتم هایی با مرتبه زمانی $n$ ، $n^{2}$ و $n^{3}$ را مسائل رام نشدنی می نامند.\\
		\textcolor{c_green}{2. مسائلی که نوشتن یک الگوریتم کارآمد برای آنها غیر ممکن است مسائل رام نشدنی می گویند.} \\
		3. الگوریتم هایی که مرتبه زمانی آنها چند جمله ای باشد را مسائل رام نشدنی می نامند.\\
		4. الگوریتم هایی که مرتبه زمانی آنها logn و nlogn باشد را مسائل رام نشدنی می گویند. 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 306 کتاب، مسائلی که نوشتن یک الگوریتم کارآمد برای آنها غیر ممکن است را مسائل رام نشدنی 
		Intractable می گویند که الگوریتم زمانی آنها غیر چند جمله ای است. و چون مسائلی که الگوریتم های زمانی آنها 
		چند جمله ای باشد حلشان ساده بوده و رام نشدنی به حساب نمی آیند، 
		لذا گزینه های یک و سه و چهار رام نشدنی نمی باشند و تنها گزینه دوم صحیح است.\\ \, \\}}
	\end{flushright}





	\paragraph{\textcolor{c_orange}{سوالات تشریحی:}}
	\paragraph{1-} الگوریتم بازگشتی برای محاسبه فاکتوریل یک عدد نوشته و زمان اجرای الگوریتم را تحلیل کنید.
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ: 
		می دانیم: 
		\begin{flushleft}
			$n! =
			\begin{cases}
				1 & if n=0\\
				n(n-1)! & if n >0
			\end{cases}$
			\begin{flushright} 
				تابع بازگشتی:
			\end{flushright}
			\begin{latin}
				int fact(int n)\\
				\{\\
				\hspace{0.5cm}if(n==0) 
				\hspace{1cm}return (1);\\
				\hspace{0.5cm}else\\
				\hspace{1cm}return (n*fact9n-1));\\
				\}
			\end{latin}
			\begin{flushright} 
				توجه به تابع بازگشتی فوق الگوریتم محاسبه فاکتوریل را برای n=3 شرح می دهیم:
			\end{flushright}
			\lr{\small{fact (3)\,\,\,\,\,\, [ ] $\rightarrow$ fact (2) \,\,\,\,\,\,\,[A:3] 
			$\rightarrow$ fact (1) \,\,\,\,\,\,[A:3 , B:2] $\rightarrow$ fact (0) \,\,\,\,\, [A:3 , B:2 , C:1]\\ 
			return (6) [ ] $\leftarrow$ return (2) [A:3] $\leftarrow$ return (1) [A:3 , B:2]
			 $\leftarrow$ return (1) [A:3 , B:2 , C:1]}}\\
			\begin{flushright} 
			قبل از فراخوانی اول پشته خالی بوده\\
			در اولین فراخوانی آدرس مقدار n در پشته ذخیره می شود ، از مقدار n یکی کم شده  و تابع مجددا فراخوانی می شود
			عملیات بالا تا جایی ادامه می یابد که n=0 شود\\
			در n=0 مقدار \underline{یک} بازگشت داده می شود و عملیات بازگشت آغاز می شود\\
			به ازای هر مرحله بازگشت یک عمل حذف از بالای پشته انجام می گیرد\\
			تا زمانی که پشته خالی نشده باشد عمل بازگشت ادامه می یابد \\
			با خالی شدن پشته، مقدار محاسبه شده توسط تابع همان مقدار بازگشت شده نهایی خواهد بود\\ \, \\
			زمان اجرای الگوریتم فاکتوریل: \\
			در حالت کلی، تابع n بار فراخوانی می شود و تعداد گره های درخت بازگشت آن، زمان اجرای الگوریتم خواهد بود.
			 لذا \lr{\small{T(n)$\in$ O(n)}}\\
			\end{flushright}
			$T(n) =
			\begin{cases}
				C & if n=0\\
				T(n-1)+C & if n >0
			\end{cases}$\\
			\lr{\small{$T(n)= T(n-1)+C = T(n-2)+2C =$ ...$= T(1)+(n-1)C=T(0)+nC-(n+1)C$}\\
			$\Rightarrow \mathbf{T(n) \in∈O(n)}$}
		\end{flushleft}
		}}
	\end{flushright}
	
	
	
	
	\paragraph{3-} رابطه $T(n)=T( \lceil ⌈\frac{n}{2} \rceil ⌉)+1$ را با روش حدس و استقرا حل نمایید.
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ: \\ \, \\
			حدس:
			\begin{flushleft} \lr{$T(n) \in O(Log \,n)  \Rightarrow \exists C> 0 : T(n) \leq C\, Log \,n$}\\ \end{flushleft}
			پایه استقرا:
			\begin{flushleft} \lr{$n=2 \Rightarrow T(2) \leq C\, log \,2= C  \geq T(2) > 0 \,\, \checkmark $}\\ \end{flushleft}
			فرض استقرا:
			\begin{flushleft} \lr{$ \forall k < n : T(k) \leq C\, log_{2} k$}\\ \end{flushleft}
			حکم استقرا:
			\begin{flushleft} \lr{$ \forall n : T(n) \leq C\, log_{2} n$}\\
			\lr{$ T(n) \leq C\, log_{2} ( \lceil ⌈\frac{n}{2} \rceil ⌉)+1\leq C\, log \,n - C +1 \leq C\, log \,n 
			\Rightarrow \forall C \geq  1 : \mathbf{T(n) \in∈O( log \,n)}$} \end{flushleft}
		}}
	\end{flushright}




	\paragraph{5-} اجزا تشکیل دهنده یک الگوریتم حریصانه را نام برده و شرح دهید.


	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		اجزاء تشکیل دهنده یک الگوریتم حریصانه عبارت اند از:
		\begin{itemize}
		\item[--] مجموعه ای از انتخاب های ممکن برای مولفه های جواب به نام C و مجموعه مولفه های انتخاب شده تا به حال به نام S .
		\item[--] روالی به نام Select برای انتخاب مولفه های بعدی جواب از مجموعه انتخاب های ممکن.
		\item[--] روالی به نام Feasible که عنصر انتخاب شده توسط روال Select را جهت قرار گرفتن در مجموعه جواب یا رد آن بررسی میکند.
		\item[--] روالی به نام Solution برای بررسی اینکه مشخص کند در نهایت جواب حاصل شده است یا خیر.
		\item[--] یک تابع هدف که هدف بهینه کردن این تابع است. 
		\end{itemize}
}}
	\end{flushright}



	
	
	
	
	
	
	\newpage
	\paragraph{\textbf{نیمسال دوم 93-94 – سوالات زوج}}
	\paragraph{\textcolor{c_orange}{سوالات تستی:}}




	\paragraph{2-}در الگوریتم زیر در صورتی که n=m باشد مرتبه اجرایی برابر است با:
	\begin{flushleft}                           
		\begin{latin}
			For i=1 to n Do\\
			\hspace{0.5cm}For j:=1 to m do\\
			\hspace{1cm}For k:=1 to j do\\
			\hspace{1.5cm}X:=x+1;\\
		\end{latin}
	\end{flushleft}
	
	\begin{flushright} 
		\,\,1. $O(\frac{m+1}{2})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $O(n^{2})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $O(\frac{m(m+1)}{2})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{4. $O(n^{3})$}
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ: 
		بر اساس صفحه 8 کتاب، $n+1$ بار سطر اول، $(m+1)*n$ بار سطر دوم، $(m+1)*m*n$ بار سطر سوم
		 و $m*m*n$ بار سطر چهارم با ثابت $C1$ و $C2$ و $C3$ و $C4$ اجرا می شوند.
		  با در نظر گرفتن ثابت $C$ به عنوان بیشترین مقدار $C1$ تا $C4$ ، خواهیم داشت:
		\begin{flushleft}
			$T(n)=(n+1)C1+(m+1)nC2+(m+1)mnC3+m^{2}nC4 \,,\, n=m $\\
			$\Rightarrow T(n)=C(2n+2n^{2}+2n^{3}+1) \Rightarrow T(n)  \in∈O(n^{3})$
			\begin{flushright} 
			همچنین می توان گفت با در نظر گرفتن ثابت زمانی $C$، خواهیم داشت:
			\end{flushright}
			$T(n)=\sum^{n}_{i=1}\sum^{n}_{j=1}\sum^{n}_{k=1} C= n*m*m*C \,,\, n=m$\\
			$\Rightarrow T(n)=n^{3}C \Rightarrow \mathbf{T(n)  \in∈O(n^{3})}$
		\end{flushleft}
		لذا گزینه چهارم صحیح است.\\}}
	\end{flushright}




	\paragraph{4-}در ضرب سه آرایه $A(3,4) , B(4,6) , C(6,2)$ به ترتیب $A*B*C$ چند عمل ضرب انجام می شود؟
	
	\begin{flushright} 
		\,\,1. $25$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{\,2. $108$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $2592$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. $3456$
	\end{flushright}
	
	
	\begin{flushright} 
	\justify{\textcolor{c_purple}{پاسخ: 
		بر اساس صفحه 199 کتاب، ضرب ماتریس ixj در ماتریس jxk ، تعداد i x j x k عملیات ضرب خواهد داشت. 
		با توجه به اینکه در مساله فوق یکبار ماتریس A در ماتریس B ضرب می شود و یکبار حاصلضرب ماتریس A و  B در ماتریس C 
		ضرب می گردد، لذا تعداد عملیات ضرب از مجموع تعداد عملیات هر دو ضرب حاصل خواهد شد. لذا گزینه دوم صحیح است.
		\begin{flushleft}
			\lr{: $3*4*6 = 72$} \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, \lr{A$_{3*4}$  $\times$ B$_{4*6}$} \rl{تعداد عملیات ضرب } \\
			\lr{: $3*6*2 = 36$} \,\,\,\, \lr{(A$\times$B)$_{3*6}$  $\times$ C$_{6*2}$} \rl{تعداد عملیات ضرب } \\
			\lr{: $72 + 36 = 108$} 
			\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,  \rl{مجموع عملیات ضرب } \\
		\end{flushleft}
		}}
	\end{flushright}




	\paragraph{6-}مرتبه زمانی رابطه بازگشتی $T(n)=9T(\frac{n}{3})+n$ برابر است با:
	 
	\begin{flushright} 
		\textcolor{c_green}{\,\,1.  $O(n^{2})$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $O(n^{log\,n})$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $O(log\,n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. $O(n)$ 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 65 کتاب، طبق قضیه اصلی داریم: 
		\begin{flushleft}
			$\begin{cases} a=9 , b=3 \\ F(n) = n\end{cases}
			\Rightarrow n^{log_{b}a}=n^{2} \Rightarrow 
			\begin{cases} F(n) \in O(n^{log_{b}a-\varepsilon}) \\ \varepsilon>0 \end{cases}
			\Rightarrow T(n) \in O(n^{log_{b}a})$ \\
			$\Rightarrow \mathbf {T(n) \in O(n^{2})}$
		\end{flushleft}
		با توجه به قضیه، مرتبه زمانی از رابطه $T(n) \in O(n^{log_{b}⁡a})$ حاصل خواهد شد.
		 لذا طبق محاسبات فوق گزینه اول صحیح است\\}}
	\end{flushright}




	\paragraph{8-}چند مورد از عبارات زیر صحیح می باشد؟
	 \begin{itemize}
		\item[--] الگوی جستجو برای روش عقبگرد به صورت جستجو در پهنا می باشد.
		\item[--] در روش انشعاب و تحدید روش جستجوی درخت به ترتیب عمق می باشد.
		\item[--] در هر دو روش بازگشت به عقب و انشعاب و تحدید شاخه هایی از درخت هرس می شود.
	\end{itemize}
	\begin{flushright} 
		\,\,1.  $3$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2.  $2$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{3.  $1$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4.  $0$
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 288 و 289 کتاب، روش عقبگرد به صورت جستجو در عمق می باشد و حال آنکه در روش انشعاب و تحدید 
		جستجو به ترتیب پهنا می باشد. اما در هر دو روش شاخه هایی از درخت هرس می شود و درنتیجه زمان لازم برای 
		اجرای الگوریتم کاهش می یابد. لذا با غلط بودن عبارت اول و دوم صحیح بودن عبارت سوم، تنها یک عبارت صحیح است.\\}}
	\end{flushright}




	\paragraph{10-}کدامیک از مرتبه زمانی های زیر جزو مسائل رام نشدنی نمی باشد؟
	 
	\begin{flushright} 
		\,\,1.  $2^{n}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2.  $3^{n}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{3.  $n^{4}$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4.  $n!$
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 306 کتاب، هر الگوریتمی که مرتبه زمانی آن غیر چند جمله ای باشد (یعنی نمایی باشد) را 
		مسائل رام نشدنی می نامند. لذا عبارات به توان $n$ و یا عبارات فاکتوریلی $n$ به صورت نمایی بوده و رام نشدنی است
		 و تنها $n^{4}$ که چند جمله ای است پاسخ صحیح سوال می باشد.\\}}
	\end{flushright}





	\paragraph{12-}تعداد درخت های جستجو با عمق n-1 برابر است با:
	 
	\begin{flushright} 
		\,\,1.  $2^{n}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{\,2.  $2^{n-1}$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3.  $2^{n+1}$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4.  $3^{n+1}$
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 214 و 244 کتاب، با در نظر گرفتن عمق $n-1$ ، تعداد $n$ سطح و هر سطح یک گره خواهیم داشت که 
		گره سطح اول یا سطح ریشه یک حالت و در سایر سطوح هر گره دو حالت (راست یا چپ) خواهد داشت. لذا تعداد درخت
		 با عمق $n-1$ برابر خواهد بود با حاصلضرب تعداد حالت گره ها.
		  \lr{$1*2*2*$…$*2 = 1*2^{n-1}=2^{n-1}$}  . لذا گزینه دوم صحیح است.\\}}
	\end{flushright}
	
	
	
	
	\paragraph{14-}الگوریتم تولید کننده کد هافمن ، ..................... .
	 
	\begin{flushright} 
		\textcolor{c_green}{\,\,1. همیشه درخت بهینه تولید می کند.}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. گاهی اوقات درخت بهینه تولید می کند.\\
		3. هیچ وقت درخت بهینه تولید نمی کند.\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. اغلب اوقات درخت بهینه تولید می کند. 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 183 کتاب، با توجه به اینکه سیستم کد گذاری تعریف شده در الگوریتم تولید کد هافمن 
		از نوع درخت دودویی بوده و همواره بهینه خواهد بود، لذا الگوریتم مذکور همواره درخت بهینه تولید می کند.\\}}
	\end{flushright}




	\paragraph{16-}کدام الگوریتم یالی را (از بین رئوس همسایه) در هر مرحله انتخاب می کند که منجر به حداقل افزایش در مجموع هزینه ها می گردد؟
	 
	\begin{flushright} 
		\,\,1. کروسکال\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{\,2. پریم}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. سولین\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. دیکسترا 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 142 کتاب، الگوریتم پریم با یک گره دلخواه شروع می کند، یالی را انتخاب می کند که منجر به 
		حداقل افزایش در مجموع هزینه هایی گردد که تا به حال درنظر گرفته شده است. 
		و زمانی که کلیه گره ها افزوده شود کار پایان می یابد. لذا مجموع هزینه یال های این درخت کمترین مقدار است..\\}}
	\end{flushright}




	\paragraph{18-}کدام روش پیشنهاد می کند که می توان الگوریتمی نوشت که مرحله به مرحله اجرا شود و در هر زمان یک ورودی را بررسی نماید و بررسی انجام شده در مورد شدنی بودن یا نبودن جواب ها می باشد؟
	 
	\begin{flushright} 
		\,\,1. روش تقسیم و حل\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\textcolor{c_green}{\,2. حریصانه}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. برنامه نویسی پویا\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. عقبگرد 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 134 کتاب، روش حریصانه پیشنهاد می کند که می توان الگوریتمی نوشت که مرحله به مرحله اجرا شود 
		و در هر زمان یک ورودی را برسی نماید که بررسی انجام شده در مورد شدنی بودن یا نبودن جواب ها می باشد. 
		اگر نتیجه بررسی منفی باشد، جواب نشدنی بوده و در غیر اینصورت، ورودی بررسی شده توسط 
		روالی به نام select به مجموعه جواب افزوده می شود.\\}}
	\end{flushright}




	\paragraph{20-}بکارگیری روش تقسیم و حل برای کدامیک از مسئله های زیر مناسب نمی باشد؟
	 
	\begin{flushright} 
		\textcolor{c_green}{\,\,1. سری فیبوناچی}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. مرتب سازی ادغام\\
		3. مرتب سازی سریع\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. ضرب ماتریس ها به روش استراسن
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 120 کتاب، بکارگیری روش تقسیم و حل برای طراحی الگوریتم مسائلی با اندازه $n$ که اندازه زیر مسئله های آن 
		نیز تقریبا برابر $n$ و یا $n/c$ ($c$ ثابت است) می باشد، مناسب نیست. لذا در مسائلی مانند سری فیبوناچی به دلیل اینکه 
		هر زیر مسئله تقریبا به اندازه مسئله اولیه طول دارد، پیچیدگی زمانی الگوریتم آن از نوع نمایی بوده و مناسب نمی باشد. 
		همچنین بر اساس صفحه 97 کتاب، الگوریتم مرتب سازی ادغامی با پیچیدگی زمانی $\theta(n\, log\, n)$ ، و بر اساس 
		صفحه 104 کتاب، الگوریتم مرتب سازی سریع با پیچیدگی زمانی $\theta(n^{2})$ ، و بر اساس صفحه 111 کتاب، 
		الگوریتم ضرب ماتریس ها به روش استراسن با پیچیدگی زمانی $\theta(n^{2})$ ، 
		هر سه در طراحی الگوریتم خود از روش مستقیم و حل استفاده می کند..\\}}
	\end{flushright}




	\paragraph{22-}بدترین حالت الگوریتم Quick sort چه زمانی رخ می دهد؟
	 
	\begin{flushright} 
		\,\,1. داده ها از قبل به صورت صعودی مرتب شده باشند.\\
		\,2. داده ها از قبل به صورت نزولی مرتب شده باشند.\\
		\textcolor{c_green}{3. داده ها از قبل مرتب شده باشند.}\\
		4. به وضعیت ورودی داده ها بستگی ندارد. 
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 103 کتاب، در الگوریتم  QUICK SORT بدترین شرایط زمانی رخ می دهد که در مجموعه داده ها، هیچ دو 
		یا چند مجموعه برابر وجود نداشته باشد و در هر بار فراخوانی پارتیشن، یک زیر مجموعه حاصل، تهی و زیر مجموعه دیگر 
		شامل کلیه داده ها به استثنای عنصر محوری باشد. و این حالت زمانی رخ می دهد که این مجموعه داده ها از قبل مرتب 
		شده باشند. با توجه به اینکه گزینه اول و دوم حالت خاصی از پاسخ بوده و کامل نیستند و گزینه چهارم نیز شرط اولیه 
		را نقض میکند، لذا تنها گزینه سوم صحیح است.\\}}
	\end{flushright}




	\paragraph{24-}زمان یک جستجوی موفق در بدترین حالت در الگوریتم جستجوی دودوئی برابر است با:
	 
	\begin{flushright} 
		\textcolor{c_green}{\,\,1. $O(log\,n)$}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		\,2. $O(n\,log\,n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		3. $\theta(n\,log\,n)$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
		4. $\theta(log\,n)$
	\end{flushright}
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		بر اساس صفحه 53 کتاب، اگر X در محدوده $[2^{k-1},2^{K}]$ باشد آنگاه الگوریتم BinSrch حداکثر $k$ مقایسه عنصر 
		برای یک جستجوی موفق انجام می دهد. و چون $k -1 \leq  Log\,n < k$ ، لذا زمان یک جستجوی موفق در بدترین حالت 
		$O(Log n)$ خواهد بود.\\}}
	\end{flushright}





	\newpage
	\paragraph{\textcolor{c_orange}{سوالات تشریحی:}}
	\paragraph{2-} فرض کنید لیستی حاوی عناصر 17,20,10,25,11,8,18 باشد. با استفاده از مرتب سازی سریع این لیست را مرتب نمایید.
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		اولین عنصر را به عنوان عنصر محور انتخاب میکنیم. عناصر کوچکتر را در سمت چپ و عناصر بزرگتر را در سمت راست 
		لیست قرار می دهیم. سپس زیر لیست های ایجاد شده را همانند مرحله قبل مرتب سازی می کنیم.
		\small{\begin{itemize}
		\item[--] در اولین مرحله عدد \textcolor{red}{17} به عنوان عنصر محور انتخاب می شود.
		 تابع QuickSort با مقادیر 0 و 6 فراخوانی می شود. 
		با اجرای تابع پارتیشن، عناصر لیست به ترتیب زیر مرتب می شوند \\
		\lr{\textcolor{red}{17} \;\; 20 \;\,\; 10 \;\; 25 \;\; 11 \;\; 08 \;\; 18}\\
		\lr{17 \, \colorbox{yellow}{10} \, \colorbox{yellow}{20} \, 25 \;\; 11 \;\; 08 \;\; 18}\\
		\lr{17 \;\; 10 \,\; \colorbox{yellow}{11} \, 25 \; \colorbox{yellow}{20} \, 08 \;\; 18}\\
		\lr{17 \;\; 10 \;\,\; 11 \; \colorbox{yellow}{08} \, 20 \; \colorbox{yellow}{25} \, 18}\\
		\lr{\colorbox{yellow}{08} \, 10 \;\,\; 11 \; \colorbox{yellow}{17} \, 20 \;\; 25 \;\; 18}
		\item[--] در مرحله بعد زیر لیست سمت چپ عنصر محور اولیه (17) مرتب خواهد شد
		\item[--] عدد \textcolor{red}{8} به عنوان عنصر محور انتخاب می شود. تابع QuickSort با مقادیر 0 و 2 فراخوانی می شود. 
		با اجرای تابع پارتیشن، عناصر لیست مرتب می شوند (چون از قبل مرتب بوده نتیجه تغییری نخواهد کرد)\\
		\lr{\textcolor{red}{08} \; 10 \; 11 \; 17 \; 20 \; 25 \; 18}
		\item[--] عدد \textcolor{red}{10} به عنوان عنصر محور انتخاب می شود. تابع QuickSort با مقادیر 1 و 2 فراخوانی می شود. 
		با اجرای تابع پارتیشن، عناصر لیست مرتب می شوند (چون از قبل مرتب بوده نتیجه تغییری نخواهد کرد)\\
		\lr{08 \; \textcolor{red}{10} \; 11 \; 17 \; 20 \; 25 \; 18}
		\item[--] عدد \textcolor{red}{11} به عنوان عنصر محور انتخاب می شود. تابع QuickSort با مقادیر 2 و 6 فراخوانی می شود. 
		با اجرای تابع پارتیشن، عناصر لیست مرتب می شوند (چون از قبل مرتب بوده نتیجه تغییری نخواهد کرد) \\
		\lr{08 \; 10 \; \textcolor{red}{11} \; 17 \; 20 \; 25 \; 18}
		\item[--] زیر لیست سمت چپ مرتب شده و در مرحله بعد زیر لیست سمت راست عنصر محور اولیه (17) مرتب خواهد شد.
		\item[--] عدد \textcolor{red}{20} به عنوان عنصر محور انتخاب می شود. تابع QuickSort با مقادیر 1 و 2 فراخوانی می شود. 
		با اجرای تابع پارتیشن، عناصر لیست به ترتیب زیر مرتب می شوند\\
		\lr{08 \;\; 10 \;\; 11 \;\; 17 \;\; \textcolor{red}{20} \;\;\;\, 25 \;\;\; 18\;}\\
		\lr{08 \;\; 10 \;\; 11 \;\; 17 \;\; 20 \;\; \colorbox{yellow}{18} \, \colorbox{yellow}{25}}\\
		\lr{08 \;\; 10 \;\; 11 \;\; 17 \; \colorbox{yellow}{18} \, \colorbox{yellow}{20} \;\; 25\;}
		\item[--] با تغییر اندیس عنصر محور به عدد 6 (عنصر آخر لیست)، عملیات مرتب سازی با خروجی زیر پایان مییابد.\\
		\lr{08 \; 10 \; 11 \; 17 \; 18 \; 20 \; 25\;}
		\end{itemize}}
		}}
	\end{flushright}
	
	
	
	
	\paragraph{4-} الگوریتم فلوید را نوشته و پیچیدگی زمانی این الگوریتم را بدست آورید.
	
	
	\begin{flushright} 
		\justify{\textcolor{c_purple}{پاسخ:
		می دانیم:
		\begin{flushleft}
			\lr{$D^{k} (i,j)=min⁡{D^{k-1} (i,j)  ,D^{k-1} (i,k)+D^{k-1} (k,j)}$}\\ \, \\
			\begin{flushright}
				W : آرایه دو بعدی گراف جهت دار و وزن دار با n راس که W[i][j] وزن یال بین دو راس i و j میباشد. \\
				D : آرایه دو بعدی که سطرها و ستونهای آن از 0 تا n-1 اندیس گذاری شده
				 و W[i][j] وزن کوتاهترین مسیر بین راس i و j میباشد. 
			\end{flushright}
			\lr{void Floyd (int n , float W[ ] [n] , float D[ ] [n-1])\\
			\{ \\
			\hspace{0.5cm}int i , j , k ;\\
			\hspace{0.5cm}D = W ;\\
			\hspace{0.5cm}for (k = 1 ; k $\leq$  n ; k ++)\\
			\hspace{1cm}for (i = 0 ; i < n ; i ++)\\
			\hspace{1.5cm}for (j = 0 ; j < n ; j ++)\\
			\hspace{2cm}D[i][j] = min(D[i][j] , D[i][k] + D[k][j]) ;\\
			\}}
		\end{flushleft} 
		در این الگوریتم k حالت از 1 تا n را در نظر میگیریم. برای هر حالت یک سطر i را در نظر میگیریم. به ازای هر سطر، ستون های j 
		متناظر با آن را در نظر میگیریم. برای هر ستون کمترین مقدار آرایه به نسبت حالت انتخاب شده را در D آن سطر و ستون جایگذاری 
		میکنیم. عملیات جایگزین کردن کمترین مقدار \lr{D$_{i,j}$} به نسبت k را برای تمام n ستون و n سطر و در تمام n حالت k انجام میدهیم. 
		با پایان یافتن هر سه حلقه تو در تو، مقدار نهایی آرایه D، کوتاهترین مسیر ها را  دربرخواهد داشت\\ \, \\
		پیچیدگی زمانی : با توجه به سه حلقه تو در تو با عمل اصلی محاسبه مقدار، خواهیم داشت:
		\flushleft{$T(n)=n*n*n=n^{3} \Rightarrow \mathbf {T(n)\in ∈\theta(n^{3})}$}
		. \\}}
	\end{flushright}


	
	

\end{document}